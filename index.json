[
{
	"uri": "https://www.enginego.org/%E5%B7%A5%E5%85%B7/docker/",
	"title": "docker教程",
	"tags": [],
	"description": "",
	"content": " 安装以及使用docker "
},
{
	"uri": "https://www.enginego.org/%E5%B7%A5%E5%85%B7/wireshark/",
	"title": "wireshark教程",
	"tags": [],
	"description": "",
	"content": " 安装以及使用wireshark "
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/",
	"title": "基础知识",
	"tags": [],
	"description": "",
	"content": " 基础知识 这章解释了计算机基础中常见的术语以及常见问题。\n"
},
{
	"uri": "https://www.enginego.org/%E5%B7%A5%E5%85%B7/",
	"title": "工具教程",
	"tags": [],
	"description": "",
	"content": " 配置基础开发环境 我们开始安装一些工具来方便我们学习编程，一般初接触编程的同学使用的都是Windows系统或者macOS系统。从这节课开始我们将使用Linux系统来学习编程，不同于Windows以及macOS系统，\n Linux系统是一个开源(open source)系统，也就是说它的所有源代码都可以让大家浏览以及审核，提出修改。\n 如何在Windows系统或者macOS系统上运行Linux系统呢？我们可以使用Docker来在本地使用Linux系统。\n"
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/",
	"title": "常见问题",
	"tags": [],
	"description": "",
	"content": " 常见问题 这里包含了计算机初学者常见的问题 "
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/",
	"title": "术语",
	"tags": [],
	"description": "",
	"content": " 基础术语 一般我们从搜索引擎得到的名词解释都非常难懂，我希望用实际生活的例子来解析这些计算机的基础术语 "
},
{
	"uri": "https://www.enginego.org/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/",
	"title": "机器学习",
	"tags": [],
	"description": "",
	"content": " 机器学习基础 "
},
{
	"uri": "https://www.enginego.org/",
	"title": "目录",
	"tags": [],
	"description": "",
	"content": " 计算机基础首页 作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n在我们建立EngineGirls组织的时候，本意是希望组织定期的线下课程，向女性教授计算机编程的知识。她们对计算机很有热情，也希望学习到数据分析，网络爬虫，人工智能等方面的知识，从而运用在她们工作上。不过在教学的过程中, 我们发现课程往往花费了大量时间在解答计算机的基础知识。例如什么是终端（Terminal），路径（PATH），环境变量 (PATH)等术语。另外更重要的是，如果缺乏这些计算机的基础，即使最终学生们可以依葫芦画瓢写出一个应用，也并没有学到真正的知识，因为她们并没有真正的理解自己学到了什么。\n其实在刚接触编程的时候，我也常常被这些术语所困扰，而且在网上也没找到通俗易懂的解释。我希望各位可以把这本电子书当作计算机基础的入门课，令你不用因为专业术语而对编程却步。除此之外，我推荐可以上udacity的初级教程，里面有来自世界顶尖公司的工程师讲解，视频还穿插着精心选择的习题，包括我也在里面学习到非常多的知识，更重要的是，很多课程都是免费的。:D\n学习完这一部分的课程并不能使你成为一位程序员，你不需要成为一名程序员，你可以是会编程的老师，会编程的助理，这点可以使你在行业中更具有竞争力。而且世界上很多问题都没被解决。当你学会编程，用编程的眼光再去看自己平常的工作，或者就能找到一些属于你们行业的独特的问题，去解决它们。\n不要听别人说编程很难，或者你学不会这样的鬼话，相信自己的能力，去尝试，去努力一次。大部分程序员都不是从小就会计算机的，大部分程序员数学都很一般，大部分靠的只是刻苦。最后我引用鲁迅的一段话，共勉：\n 所以我时常害怕，愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。 此后如竟没有炬火：我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失，不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。\n 让我们开始吧 :D\n"
},
{
	"uri": "https://www.enginego.org/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/",
	"title": "贝叶斯分类器",
	"tags": [],
	"description": "",
	"content": " 作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处（www.enginego.org）。\n贝叶斯模型在机器学习以及人工智能中都有出现，cherry分类器使用了朴素贝叶斯模型算法，用少数的数据量（1000个句子）得到97.5%的准确率。在这篇文章我会介绍贝叶斯模型的理论，实现以及误差分析，我清楚现在主流的框架都带有朴素贝叶斯模型算法的实现，大多人只需要调用一个函数就可以达到相近的准确率，但是在现实使用中，当遇到不同的数据集，必须要了解算法的原理才知道如何调参。\n贝叶斯模型理论  分类器使用 关键字过滤 贝叶斯模型推导 贝叶斯模型实现 测试 统计分析  分类器使用 基础术语：  训练数据\n带有人工标识类别的数据集\n 输入句子\n需要判断类别的新句子（通常不应该出现在训练数据中）\n  默认数据缓存中，中文训练数据包含正常，政治敏感，赌博，色情4个类别，英文训练数据包含正常邮件，垃圾邮件两个类别，训练数据可以通过Google drive下载。输入句子：\n 警方召开了全省集中打击赌博违法犯罪活动专项行动电视电话会议。会议的重点是“查处”六合彩、赌球赌马等赌博活动。\n \u0026gt;\u0026gt;\u0026gt; result = cherry.classify('警方召开了全省集中打击赌博违法犯罪活动专项行动电 电话会议。会议的重点是“查处”六合彩、赌球赌马等赌博活动。') Building prefix dict from the default dictionary ... Loading model from cache /var/folders/md/0251yy51045d6nknpkbn6dc80000gn/T/jieba.cache Loading model cost 0.894 seconds. Prefix dict has been built succesfully. \u0026gt;\u0026gt;\u0026gt; result.percentage [('normal.dat', 0.997), ('politics.dat', 0.002), ('gamble.dat', 0.0), ('sex.dat', 0.0)] \u0026gt;\u0026gt;\u0026gt; result.word_list [('赌博', 8.5881312727226), ('活动', 6.401543938544878), ('会议', 6.091963362021649), ('违法犯罪', 4.234845736802978), ('警方', 3.536827626008435), ('打击', 3.2491455535566542), ('行动', 2.8561029654470476), ('查处', 2.3860993362013083), ('重点', 2.126816738271229), ('召开', 1.8628511924367634), ('专项', 1.1697040118768172), ('电视电话会议', 1.1697040118768172), ('全省', 0.47655683131687354), ('集中', -0.6220554573512382), ('六合彩', -2.29603189092291)]  分类器判断输入句子有99.7%的概率是正常句子，0.2%是政治敏感，其中对分类器判断影响最大的词语分别是\n赌博，活动，会议，违法犯罪  关键字过滤 判断输入句子是什么类别，最简单和原始的方法是使用关键词过滤，输入句子：\n 奖金将在您完成首存后即可存入您的账户。真人荷官，六合彩，赌球欢迎来到全新番摊游戏！\n 因为真人荷官，六合彩这两个词语一般是赌博类的句子才会出现，使用关键字过滤的方法，我们可以将它加入赌博类别的黑名单，当再遇到句子包含这些黑名单词语，就判断成赌博类别。\n这个方法实现简单，但是缺点也很明显。例如遇到刚刚这个输入句子：\n 警方召开了全省集中打击赌博违法犯罪活动专项行动电视电话会议。会议的重点是“查处”六合彩、赌球赌马等赌博活动。\n 虽然输入句子包含六合彩，赌球这两个词语，不过是正常的句子，所以关键词过滤算法很容易出现误判。\n贝叶斯模型推导 关键词过滤的问题在于只对输入句子中的几个词语进行分析，没有对输入句子的整体进行分析，当人类去判断输入句子：\n 警方召开了全省集中打击赌博违法犯罪活动专项行动电视电话会议。会议的重点是“查处”六合彩、赌球赌马等赌博活动。\n 我们会综合分析句子中的每个词语：\n警方，召开，全省，集中打击，... 六合彩，赌球，赌马，...  它虽然包含六合彩这个关键词，但是警方，召开，集中打击这几个词代表这个句子极有可能是正常的句子。\n贝叶斯模型也一样，相对于关键词过滤只着重于输入句子中的某几个词语，贝叶斯模型会对输入句子的所有有效词语进行分析，通过训练数据计算每个词语在不同类别下的概率，然后综合得出最有可能的结果。贝叶斯模型的数学推导非常简单，强烈建议大家静下心自己推导。\n这里为了简单起见，我们只考虑句子是“正常”或者“赌博”两种可能，我们先复习一下概率论：\n P(输入句子) -\u0026gt; 这个句子在训练数据中出现的概率\nP(赌博) -\u0026gt; 赌博类别的句子在训练数据中出现的概率\nP(赌博|输入句子) -\u0026gt; 输入句子是赌博类别的概率（条件概率，也是我们最终要求的值）\n 对于同一个句子：\n P(赌博|输入句子) + P(正常|输入句子) = 100%\n 上图，中间重叠的部分是赌博和句子同时发生的概率P(赌博，输入句子)，可以看出：\n P(赌博|输入句子) = P(赌博，输入句子) / P(输入句子) (1)\n 同理：\n P(输入句子|赌博) = P(赌博，输入句子) / P(赌博) (2)\n 把(2)代入(1)得到\n P(赌博|输入句子) = P(输入句子|赌博) * P(赌博) / P(输入句子) (3)\n 登登登灯，(3)就是贝叶斯定理。没看懂没关系，静下心再看一遍。 要得到最终输入句子是赌博类别的概率P(赌博|输入句子)，需要知道右边3个量的值：\n P(赌博)\n指训练数据中，赌博类别的句子占训练数据的百分比。\n P(输入句子)\n指这个输入句子出现在训练数据中的概率。我们最终目的是判断输入句子是哪个类别的概率比较高，也就是比较P(赌博|输入句子)与P(正常|输入句子)，由贝叶斯定理：\n P(赌博|输入句子) = P(输入句子|赌博) * P(赌博) / P(输入句子) (4)\nP(正常|输入句子) = P(输入句子|正常) * P(正常) / P(输入句子) (5)\n 由于(4)，(5)都要除于相同的P(输入句子)，所以(4)，(5)右边可以同时乘以P(句子)，只比较等号右边前两个值的乘积的大小。\nP(赌博|输入句子) = P(输入句子|赌博) * P(赌博) P(正常|输入句子) = P(输入句子|正常) * P(正常)\n P(句子|赌博)\n最关键的就是求P(输入句子|赌博)，直接求输入句子在赌博类别句子中出现的概率非常困难，因为训练数据不可能包含所有句子，很可能并没有输入句子。什么意思呢？因为同一个句子，把词语进行不同的排列组合都能成立，例如：\n 奖金将在您完成首存后即可存入您的账户。真人荷官，六合彩，赌球欢迎来到全新番摊游戏！\n 可以变成\n 奖金将在您完成首存后即可存入您的账户。合彩，赌球，真人荷官欢迎来到全新番摊游戏！\n 或者\n 欢迎来到全新番摊游戏，奖金将在您完成首存后即可存入您的账户。六合彩，真人荷官，赌球！\n 稍微变换词语的位置就是一个新的句子了，训练数据不可能把所有排列组合的句子都加进去，因为实在太多了。所以当我们遇到一个输入句子，很可能它在训练数据中没有出现，那么P(输入句子|类别)对应的概率都为零，这显然不是真实的结果。也会导致我们的分类器出错，这个时候该怎么办呢？刚刚在关键词过滤算法中我们提到，人类会将一个句子分成不同的词语来综合分析，那我们是不是也可以把句子当成词语的集合呢？\n 警方召开了全省集中打击赌博违法犯罪活动专项行动电视电话会议。会议的重点是“查处”六合彩、赌球赌马等赌博活动。\n警方召开了全省\u0026hellip;赌马等赌博活动 = 警方 + 召开 + 全省\u0026hellip;+赌博活动\n 即：\n P(输入句子|赌博) = (P(词语1) * P(词语2|词语1) * P(词语3|词语2))|赌博) ≈ P(词语1)|P(赌博) * P(词语2)|P(赌博) * P(词语3)|P(赌博)\nP(警方召开了全省\u0026hellip;赌马等赌博活动。|赌博) = P(警方|赌博) * P(召开|赌博) * P(全省|赌博) \u0026hellip; * P(赌马|赌博) * P(赌博活动|赌博)\n 我们把P(输入句子|赌博)分解成所有P(词语|赌博)概率的乘积，计算词语在训练数据中出现的概率就容易计算得多了。我们最终获取的是输入句子有效词语不同类别中的概率，在上面的例子中，虽然赌马，赌球，赌博活动这几个词是赌博类别的概率很高，但是综合整个句子的所有词语来说，分类器判断句子有90%的概率是正常的句子。\n   词语 正常 赌博     警方 0.8 0.2   召开 0.7 0.3   全省 0.7 0.3   赌马 0.4 0.6   赌球 0.3 0.7   赌博活动 0.4 0.6   \u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;-   综合概率 0.9 0.1    简单总结，要计算句子是某类别的概率，只需要计算该句子有效部分的词语的在该类别概率的乘积。\n  贝叶斯模型实现 要计算每个词语在不同类别下出现的概率，我们需要训练数据进行训练： 1. 选择训练数据，标记类别 2. 把所有训练数据进行分词，并且组成成一个包含所有词语的词袋集合 3. 把每个训练数据转换成词袋集合长度的向量 4. 利用每个类别的下训练数据，计算词袋集合中每个词语的概率\n选择训练数据 训练数据的选择其实有很多方法，最简单的情况，我们可以从网络上搜索符合对应类别的句子，如果是二元分类的问题，可以使每个类别的数据各占一半。不过当你理解了贝叶斯模型的原理，你会发现一个问题，就是保持数据的独立分布，如果你选择的训练数据如下：\n 赌博类别\n 根据您所选择的上述礼遇，您必须在娱乐场完成总金额（存款+首存奖金）16倍或15倍流水之后，方可申请提款。\n奖金将在您完成首存后即可存入您的账户。真人荷官 六合彩 欢迎来到全新番摊游戏！\n 正常类别\n Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。\n理查德·菲利普斯·费曼，美国理论物理学家，量子电动力学创始人之一，纳米技术之父。\n  正常类别的数据中没有出现过类似六合彩，游戏这两个词语，如果仅仅使用这些数据进行训练，那么这两个词语对句子是否是赌博类别会有很大的影响性，但是游戏这个词语本身和赌博没有直接的关系，却被错误划分为赌博类别相关的词语，如果分类器遇到\n 我们提供最新最全大型单机游戏下载，迷你单机游戏下载，并提供大量单机游戏攻略\n 这类的句子，也很有可能会将它判断为赌博类别，这并不是我们的原意。所以，当我们要做一个赌博/正常的分类器，我们需要在正常类别的训练数据添加类似于：\n 中国游戏第一门户站,全年365天保持不间断更新,您可以在这里获得专业的游戏新闻资讯,完善的游戏攻略专区\n 这样的正常而且带有游戏关键字的句子。一般来说，正常的句子比赌博类别的句子出现的概率要多得多，这点也可以从训练数据的比例上面体现，可以增加正常类别句子的数量，不过要小心Accuracy_paradox的问题。我们在测试的时候，可以通过混淆矩阵以及被错分的测试数据权重最高的词语，来调整数据。 为简单起见，我们这里只选取4个句子作为训练数据：\n 赌博类别：\n 根据您所选择的上述礼遇，您必须在娱乐场完成总金额（存款+首存奖金）16倍或15倍流水之后，方可申请提款。\n奖金将在您完成首存后即可存入您的账户。真人荷官 体育博彩 欢迎来到全新番摊游戏！\n 正常类别：\n 理查德·菲利普斯·费曼，美国理论物理学家，量子电动力学创始人之一，纳米技术之父。\n在公安机关持续不断的打击下，六合彩、私彩赌博活动由最初的公开、半公开状态转入地下。\n  词袋集合 要计算每个词语在不同类别下的概率，首先需要一个词袋集合，集合包含了训练数据中所有非重复词语(_vocab_list)，参考函数_vocab_list：\ndef _get_vocab_list(self): ''' Get a list contain all unique non stop words belongs to train_data Set up: self.vocab_list: [ 'What', 'lovely', 'day', 'like', 'gamble', 'love', 'dog', 'sunkist' ] ''' vocab_set = set() all_train_data = ''.join([v for _, v in self._train_data]) token = Token(text=all_train_data, lan=self.lan, split=self.split) vocab_set = vocab_set | set(token.tokenizer) self._vocab_list = list(vocab_set)  我们使用结巴分词，把训练数据的句子分成词语的集合，例如第一个数据：\n 根据您所选择的上述礼遇，您必须在娱乐场完成总金额（存款+首存奖金）16倍或15倍流水之后，方可申请提款。\n 分词后会得到：\n['根据', '您', '所', '选择', '的', '上述', '礼遇', '，', '您', '必须', '在', '娱乐场', '完成', '总金额', '（', '存款', '+', '首存', '奖金', '）', '16', '倍', '或', '15', '倍', '流水', '之后', '，', '方可', '申请', '提款', '。']  然后去掉包含在stop_word.dat中的词语，stop_word列表包含了汉语中的常见的转折词，例如\n如果，但是，并且，不只  这些词语对于我们分类器没有用处，因为任何类别都会出现这些词语。去掉长度等于1的字以及stop_word_lst里面的词语之后，第一个句子就剩下：\n['选择', '上述', '礼遇', '娱乐场', '总金额', '存款', '首存', '奖金', '16', '15', '流水', '申请', '提款']  遍历4个句子最终得到的长度为49的词袋集合(vocab_list)就是：（这里使用的集合是无序的，所以你得到的结果顺序可能不同）\n['提款', '存入', '游戏', '最初', '六合彩', '娱乐场', '费曼', '奖金', '账户', '菲利普斯', '量子', '电动力学', '总金额', '上述', '活动', '状态', '物理学家', '公安机关', '荷官', '即可', '理论', '申请', '半公开', '选择', '15', '打击', '全新', '来到', '公开', '方可', '博彩', '完成', '理查德', '纳米技术', '不断', '存款', '之一', '创始人', '真人', '私彩', '持续', '根据', '必须', '16', '赌博', '欢迎', '体育', '转入地下', '首存', '流水', '美国', '礼遇']  得到词袋之后，再次使用训练数据，并把每个训练数据都转变成一个长度为49的一维向量\ndef _get_vocab_matrix(self): ''' Convert strings to vector depends on vocal_list ''' array_list = [] for k, data in self._train_data: return_vec = np.zeros(len(self._vocab_list)) token = Token(text=data, lan=self.lan, split=self.split) for i in token.tokenizer: if i in self._vocab_list: return_vec[self._vocab_list.index(i)] += 1 array_list.append(return_vec) self._matrix_lst = array_list   根据您所选择的上述礼遇，您必须在娱乐场完成总金额（存款+首存奖金）16倍或15倍流水之后，方可申请提款。\n 对应转变成：\n# 长度为49 [1, 0, 0, 0, 1, 0, ..., 1, 0, 1]  其中的1分别对应着数据分词后的词语在词袋中出现的次数。接下来将所有训练数据的向量结合成一个列表_matrix_list\n[ [1, 0, 0, 0, 1, 0, ..., 1, 0, 1] [0, 1, 1, 0, 0, 0, ..., 0, 0, 0] ... ]  **要计算每个词语在不同类别下的概率，只需要把词语出现的次数除以该类别的词语总数，cherry出于效率的考虑使用了numpy的矩阵运算。\ndef _training(self): ''' Native bayes training ''' self._ps_vector = [] # 防止有词语在其他类别训练数据中没有出现过，最后的P(句子|类别)乘积就会为零，所以给每个词语一个初始的非常小的出现概率，设置vector默认值为1，cal对应为2 # vector: 默认值为1的一维数组 # cal: 默认的分母，计算该类别所有有效词语的总数 # num: 计算P(赌博), P(句子) vector_list = [{ 'vector': np.ones(len(self._matrix_lst[0])), 'cal': 2.0, 'num': 0.0} for i in range(len(self.CLASSIFY))] for k, v in enumerate(self.train_data): vector_list[v[0]]['num'] += 1 # vector加上对应句子的词向量，最后把整个向量除于cal，就得到每个词语在该类别的概率。 # [1, 0, 0, 0, 1, 0, ..., 1, 0, 1] (根据您所选择的...) # [0, 1, 1, 0, 0, 0, ..., 0, 0, 0] (奖金将在您完成...) # + # [1, 1, 1, 1, 1, 1, ..., 1, 1, 1] vector_list[v[0]]['vector'] += self._matrix_lst[k] vector_list[v[0]]['cal'] += sum(self._matrix_lst[k]) for i in range(len(self.CLASSIFY)): # 每个词语的概率为[2, 2, 2, 1, 2, 1, ..., 2, 1, 2]/cal self._ps_vector.append(( np.log(vector_list[i]['vector']/vector_list[i]['cal']), np.log(vector_list[i]['num']/len(self.train_data))))  遍历完所有训练数据之后，会得到两个类别对应的每个词语的概率向量，(为了防止python的小数溢出，这里的概率都是取np.log()对数之后得到的值)：\n赌博 ([-2.80336038, -2.80336038, -2.80336038, -3.49650756, -3.49650756, -2.80336038, -3.49650756, -2.39789527, -2.80336038, -3.49650756, -3.49650756, -3.49650756, -2.80336038, -2.80336038, -3.49650756, -3.49650756, -3.49650756, -3.49650756, -2.80336038, -2.80336038, -3.49650756, -2.80336038, -3.49650756, -2.80336038, -2.80336038, -3.49650756, -2.80336038, -2.80336038, -3.49650756, -2.80336038, -2.80336038, -2.39789527, -3.49650756, -3.49650756, -3.49650756, -2.80336038, -3.49650756, -3.49650756, -2.80336038, -3.49650756, -3.49650756, -2.80336038, -2.80336038, -2.80336038, -3.49650756, -2.80336038, -2.80336038, -3.49650756, -2.39789527, -2.80336038, -3.49650756, -2.80336038]), 0.5) 正常 ([-3.25809654, -3.25809654, -3.25809654, -2.56494936, -2.56494936, -3.25809654, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -2.56494936, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -2.56494936, -2.56494936, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -3.25809654, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -3.25809654, -3.25809654, -3.25809654, -2.56494936, -2.56494936, -2.56494936, -3.25809654, -2.56494936, -2.56494936, -3.25809654, -2.56494936, -2.56494936, -3.25809654, -3.25809654, -3.25809654, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -3.25809654]), 0.5) 词袋集合 ['提款', '存入', '游戏', '最初', '六合彩', '娱乐场', '费曼', '奖金', '账户', '菲利普斯', '量子', '电动力学', '总金额', '上述', '活动', '状态', '物理学家', '公安机关', '荷官', '即可', '理论', '申请', '半公开', '选择', '15', '打击', '全新', '来到', '公开', '方可', '博彩', '完成', '理查德', '纳米技术', '不断', '存款', '之一', '创始人', '真人', '私彩', '持续', '根据', '必须', '16', '赌博', '欢迎', '体育', '转入地下', '首存', '流水', '美国', '礼遇']  把向量和词袋集合对应来看，可以看到，提款，存入，游戏这几个词是赌博的概率要大于正常的概率\n#赌博 提款，存入，游戏 [-2.80336038, -2.80336038, -2.80336038] #正常 提款，存入，游戏 [-3.25809654, -3.25809654, -3.25809654]  判断类别 训练完数据，得到词语对应概率之后，判断类别就非常简单，只需要把输入句子进行相同的分词，然后计算对应的词语对应的概率的乘积即可，乘积最大的就是最有可能的类别。例如我们要判断的句子是：\n欢迎参加澳门在线娱乐城，这里有体育，百家乐，六合彩各类精彩游戏。  同样地，先根据原先的词袋集合，先转变为一维向量\n# 词袋集合 ['提款', '存入', '游戏', '最初', '六合彩', '娱乐场', '费曼', '奖金', '账户', '菲利普斯', '量子', '电动力学', '总金额', '上述', '活动', '状态', '物理学家', '公安机关', '荷官', '即可', '理论', '申请', '半公开', '选择', '15', '打击', '全新', '来到', '公开', '方可', '博彩', '完成', '理查德', '纳米技术', '不断', '存款', '之一', '创始人', '真人', '私彩', '持续', '根据', '必须', '16', '赌博', '欢迎', '体育', '转入地下', '首存', '流水', '美国', '礼遇'] # 一维向量 [0, 0, 1, 0, 1, ...]  然后与分别与两个概率向量相乘，求和，并加上对应的类别占比\nP(赌博|句子) = sum([0, 0, 1, 0, 1, ...] * [-2.80336038, -2.80336038, -2.80336038, ...]) + P(赌博) P(正常|句子) = sum([0, 0, 1, 0, 1, ...] * [-3.25809654, -3.25809654, -3.25809654, ...])+ P(正常) 最终得到P(赌博|句子) \u0026gt; P(正常|句子)，所以分类器判断这个句子是赌博类别。  对应的代码：\ndef _bayes_classify(self): ''' Calculate the probability of different category ''' possibility_vector = [] log_list = [] # self._ps_vector: ([-3.44, -3.56, -2.90], 0.4) for i in self._ps_vector: # 计算每个词语对应概率的乘积 final_vector = i[0] * self.word_vec # 获取对分类器影响度最大的词语 word_index = np.nonzero(final_vector) non_zero_word = np.array(self._vocab_list)[word_index] # non_zero_vector: [-7.3, -8] non_zero_vector = final_vector[word_index] possibility_vector.append(non_zero_vector) log_list.append(sum(final_vector) + i[1]) possibility_array = np.array(possibility_vector) max_val = max(log_list) for i, j in enumerate(log_list): # 输出最大概率的类别 if j == max_val: max_array = possibility_array[i, :] left_array = np.delete(possibility_array, i, 0) sub_array = np.zeros(max_array.shape) # 通过曼哈顿举例，计算影响度最大的词语 for k in left_array: sub_array += max_array - k return self._update_category(log_list), \\ sorted( list(zip(non_zero_word, sub_array)), key=lambda x: x[1], reverse=True)  测试  统计分析 算法分析  统计分析 对一个句子进行分类，最终的结果会有4种类别：\n   类别 含义     真阳性(TP) 输入句子为赌博类别，分类器判断为赌博类别   假阳性(FP) 输入句子为正常类别，分类器判断为赌博类别   真阴性(TN) 输入句子为正常类别，分类器判断为正常类别   假阴性(FN) 输入句子为赌博类别，分类器判断为正常类别    一般的测试方法有留出法(hold-out)，k折交叉验证法(cross validation)，自助法(bootstrapping)，这里我们使用留出法，测试脚本默认每次从所有数据中选出60个句子当成测试数据，剩下的当成训练数据。重复进行测试10次。运行测试脚本\n\u0026gt;\u0026gt;\u0026gt; python runanalysis.py This may takes some time, Go get a coffee :D. Building prefix dict from the default dictionary ... Loading model from cache /var/folders/md/0251yy51045d6nknpkbn6dc80000gn/T/jieba.cache Loading model cost 0.914 seconds. Prefix dict has been built succesfully. +Cherry---------------+------------+------------+ | Confusion matrix | gamble.dat | normal.dat | +---------------------+------------+------------+ | (Real)gamble.dat | 249 | 0 | | (Real)normal.dat | 13 | 338 | | Error rate is 2.17% | | | +---------------------+------------+------------+  输出分类测试数据的平均错误率为2.17%，同时我们可以通过混淆矩阵对分类器进行分析：\n 查全率(recall)（能找出赌博类别句子的概率）\n真阳性/(真阳性+假阴性) 249 / 249 = 100%\n 查准率(precision)（分类为赌博类别中的句子，确实是赌博类别的概率）\n真阳性/(真阳性+假阳性) 249 / (249 + 13) = 95%\n  如果业务的需求是尽可能找到潜在的阳性数据（例如癌症初检）那么就要求高查全率，不过对应的，高查全率会导致查准率降低。（可以这样理解，假如所有句子都判断成赌博类别，那么所有确实是赌博类别的句子确实都被检测到了，但是查准率变得很低。）影响查全率以及查准率的一点是训练数据数量的比例，日常的句子中，赌博类别的句子与正常类别的句子比例可能是1:50。也就是说随便给出一个句子，不用看内容，那么它有98%是正常的。不过在某些情况下，例如热门评论区打广告的用户就很多，那么这个比例就变成1:10或者1:20，这个比例是根据具体业务而调整的。训练数据也应该遵循这个比例，但是实现中，我们必须要找到大量独立分布的数据才能遵循这个比例，同时维持高查准率和查全率。\n算法分析  错误权重 上下文关联 分类器绕过  错误权重 如果训练数据过少，输入句子包含了词袋集合模型中并没有的词语，就无法获得该词语的对应概率，如果某些词语是中性词，但是只出现在某一个类别，那么分类器也会以为该词语是关键词。我们可以在测试的过程，输出错误分类的输入句子，然后观察哪些词语被错误赋予高权重了。例如：\ndata is 每周为你推荐好吃的零食，和各种美食评测！还有萌萌的黄教授为你试验各种食物流言和爱冒险的老船长带你脑洞大开，用汽车做料理！ -------------------- percentage is [('gamble.dat', 0.955), ('normal.dat', 0.045)] -------------------- word_list is [('推荐', 2.458695507975194), ('各种', 2.3555233250262599), ('每周', 1.3600832193070849), ('冒险', 0.95461811119892026), ('评测', 0.95461811119892026), ('美食', -0.43167624992097053), ('好吃', -1.3479669817951256), ('汽车', -1.5302885385890796)]  在这个错误分类的数据中，可以看到推荐，各种这两个词语被赋予赌博类别的高权重，与我们的常识冲突，那么我们可以在正常类别的训练数据加上包含推荐，各种这两个词语的数据来降低权重，或者我们可以使用Adaboost算法动态调整权重，这个功能我们之后会加上。\n上下文关联 当我们计算P(输入句子|类别)的时候，我们把输入句子分成了词语的集合，同时假定了输入句子中词语与词语之间没有上下文关系，其实这是不完全正确的，例如：\n警方召开了全省集中打击赌博违法犯罪活动...  从常识句子的上下文判断，集中打击出现在赌博违法犯罪之前的概率，要比召开出现在赌博违法犯罪之前的概率高，不过当我们把输入句子分成词语的集合的时候，把它们看成每个词语都是独立分布的。这也是此算法称为朴素贝叶斯的原因，如果我们有大量的数据集，计算出每个词语对应词袋模型其他词语的出现概率值的话，可以提高检测的准确率。\n要注意的是，训练数据选择与最后进行分类的数据必须尽量关联，如果要检测的句子与训练数据有非常大的差别，例如检测的内容包含大量的英文单词，但是训练数据却没有，那么分类器就无法进行正确的分类。同时，输入句子过短的话，分类器也无法很好地进行分类。因为分类的结果会很容易被其中的一两个词语所影响。\n分类器绕过 分类器无法分辨重复内容或部分无意义文本，输入句子：\n 车厘子车厘子车厘子车厘子\n{{{{{{{{{{{}}}}}}}}}}}\n加入博彩121加qq看头像，很为温暖文科楼课文你问你看我呢额可能我呃让你听客啊啊爱看就是是过分过分你问人人官方代购极为。\n 前两个是垃圾内容，但是即使我们添加垃圾内容的数据集，也很难判断正确。最后一个前一小段是赌博类别的句子，后面一长串是无意义或者正常类别的句子，分类器综合判断它是正确的句子。解决这个问题我们可以用一个简单的方法，计算句子的熵，也就是无序程度。每个句子都有合理的长度以及合理的无序程度，什么意思呢？句子的长度大约遵循正态分布，极长（不包含标点符号）或者极短的句子出现的概率比较低，同时，通常一个句子中的词语不会重复出现很多次，它的无序程度是在某个范围的。当我们看到前两个句子，因为它们词语的重复度非常高，所以句子的无序度非常低，如何计算句子的无序程度呢？\n 我们找两个输入句子作为例子，先把输入句子进行分词\n 车厘子是一只非常可爱的猫咪\n车厘子车厘子车厘子车厘子\n [车厘子，非常，可爱，猫咪] [车厘子，车厘子，车厘子，车厘子]  计算每个词语出现的次数除于句子的词语数量：\nP(车厘子) = P(非常) = P(可爱) = P(猫咪) = 1\u0026frasl;4 P(车厘子) = 4\u0026frasl;4 = 1\n通过计算熵的公式，带入每个概率值，最后除于句子的词语数量\nH = -sum(p(x)log2p(x)) H1 = ((1/4 * -2) - (1/4 * -2) - (1/4 * -2) - (1/4 * -2)) / 4= -2 / 4 = -1/2 H2 = 0  可以看到，在同样的句子长度下，第一个句子的熵为-2，第二个为0，可以设置一个熵的范围，如果低于该值，代表句子可能是垃圾数据。\n  "
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/",
	"title": "理解字符串编码",
	"tags": [],
	"description": "",
	"content": " 作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处（www.enginego.org）。\n在打开网页或者文件的时候，你一定会遇过像这样的字符串乱码问题：\nÉ��OÇ��，系统包括了...  或者报错\nUnicodeDecodeError: 'ascii' codec can't decode byte 0xc4  同时或多或少也遇到Unicode, UTF-8, ASCII, Latin-1这些编码术语。要真正地理解字符串编码，必须要了解计算机的一些基础知识，包括字符串如何存储与转换。如果只是希望靠运气来解决或者避开它，反而会在一次次盲目的尝试中浪费更多的时间。\n 基础术语 计算机如何存储数据 ASCII编码 GBK编码 Unicode UTF-8编码 HTML实体编码 URL编码 常见问题 总结  基础术语  字符 字符串 键值表 字符串编码与解码  字符 A B C 天 气 エ ン コ 😁  上面的用空格分割的都是单个字符(Character)，它代表对人类能看懂的有意义的语言文字。\n字符串 Hello 天气 Hola  字符串(Stirngs)就是多个字符组成的集合\n键值表 一一对应的表，例如函数\ny = x * 2  每个x都对应着唯一的一个y值，x与y组成的集合就是键值表(Hash Table)，例如：\n1 -\u0026gt; 2 2 -\u0026gt; 4 3 -\u0026gt; 6  这里的每一个x(1, 2, 3)都有对应的y(2, 4, 6)\n字符串编码与解码 编码指将字符串按照一定的模式（例如按照键值表的转换）转换成二进制数字，然后显示或者存储。如果按照上面的键值表，要把字符串\u0026rdquo;123\u0026rdquo;存储起来的话，先要转换成对应的\u0026rdquo;246\u0026rdquo;。因为计算机实际存储的是二进制数据，所以最终存储的值是\n0010 0100 0110 2 4 6  与编码相反，字符串解码(decode)就是把二进制数据按照一定的模式转换成字符串显示。\n计算机如何存储数据 因为早期的计算机存储资源非常宝贵。所以计算机科学家们希望用最少的空间来存储字符。同时，计算机是使用二进制存储数据的，无论是文字，图片，数字还是其他数据，都是以数字\u0026rdquo;0\u0026rdquo;或者\u0026rdquo;1\u0026rdquo;存储起来的。举个例子，如果计算机要存储\u0026rdquo;BEE\u0026rdquo;这个字符串，它先根据一个字母与数字的转换表把字母转换成二进制然后存储。这里我们使用一个简单的对应表叫做EngineGo表，EngineGo表用3位的二进制数字就能表示8种不同的字符。\nEngineGo表：\n   二进制 字符 二进制 字符     000 A 100 E   001 B 101 F   010 C 110 G   011 D 111 H    当我们打开文件编辑器，添加“BEE”这3个字母并保存的时候，计算机会根据EngineGo表存储数据\n001 100 100 B E E  当读取文件的时候，计算机会猜测应该使用哪个表来把二进制数据还原为字符串，如果它猜对了，使用EngineGo表还原的话，就会重新得到\u0026rdquo;BEE\u0026rdquo;这个字符串。不过如果计算机猜错了，使用其他键值表来打开这个文件的话，最终可能会报错，也可能是乱码。\n理解了这个之后，其实就很容易理解字符串编码和解码了！\nASCII编码 计算机最初由西方国家设计以及发展，理所当然他们使用了英文作为常用的字符集，字符集包括大小写字母，数字加上一些标点符号和运算符号大概120个。3位二进制数字只能表达8个不同的字符，明显不够，最简单的解决方案就是使用更多的位来保存，7位能表示128个字符，加多1位用作错误检查。最后选择使用8位来存储字符，称为一个字节。8位数字对应的表就更长了（为了方便阅读把二进制转换成了十进制）：\n   编号 字符 编号 字符 编号 字符 编号 字符     0 NUT 32 (space) 64 @ 96 、   1 SOH 33 ! 65 A 97 a   2 STX 34 \u0026ldquo; 66 B 98 b   3 ETX 35 # 67 C 99 c   4 EOT 36 $ 68 D 100 d   5 ENQ 37 % 69 E 101 e   6 ACK 38 \u0026amp; 70 F 102 f   7 BEL 39 , 71 G 103 g   8 BS 40 ( 72 H 104 h   9 HT 41 ) 73 I 105 i   10 LF 42 * 74 J 106 j   11 VT 43 + 75 K 107 k   12 FF 44 , 76 L 108 l   13 CR 45 - 77 M 109 m   14 SO 46 . 78 N 110 n   15 SI 47 / 79 O 111 o   16 DLE 48 0 80 P 112 p   17 DCI 49 1 81 Q 113 q   18 DC2 50 2 82 R 114 r   19 DC3 51 3 83 S 115 s   20 DC4 52 4 84 T 116 t   21 NAK 53 5 85 U 117 u   22 SYN 54 6 86 V 118 v   23 TB 55 7 87 W 119 w   24 CAN 56 8 88 X 120 x   25 EM 57 9 89 Y 121 y   26 SUB 58 : 90 Z 122 z   27 ESC 59 ; 91 [ 123 {   28 FS 60 \u0026lt; 92 / 124    29 GS 61 = 93 ] 125 }   30 RS 62 \u0026gt; 94 ^ 126 `   31 US 63 ? 95 _ 127 DE    早期计算机科学家们统一用这张表作字符串编码，称为ASCII编码。存储和读取也是像使用EngineGo表一样简单。这时候存储\u0026rdquo;BEE\u0026rdquo;就会存储为：\n1000010 1000101 1000101 66 69 69 B E E  非常简单吧。\nGBK编码 ASCII编码只能表示128个字符。遇到中文，常用字就几千个肯定应付不来，其他亚洲语言也遇到这样的问题。所以一开始国内使用的并不是ASCII编码，而是GBK编码。本质其实也一样，一张更大的表，用更多的位来表示字符。GBK的编码方式比较有趣，是可变长度的编码，它为了兼容ASCII编码，使用了单字节编码和双字节编码。 如果遇到一个小于127的字符，那么编码方式就与ASCII表一样，遇到大于127的字符，就表示一个汉字。也就是说当我们把\u0026rdquo;BEE\u0026rdquo;用GBK编码存储的时候，它和使用ASCII表存储的二进制数据是一样的。 这里我们以Python3为例：\n1000010 1000101 1000101 B E E # encode是Python中编码的方法 \u0026gt;\u0026gt;\u0026gt; 'BEE'.encode('ascii') \u0026gt;\u0026gt;\u0026gt; b'BEE' # gb2312是GBK编码中的一种 \u0026gt;\u0026gt;\u0026gt; 'BEE'.encode('gb2312') \u0026gt;\u0026gt;\u0026gt; b'BEE'   这里为什么显示的是b\u0026rsquo;BEE\u0026rsquo;而不是二进制或者十六进制内容呢，是因为当你在终端输入python3，运行解释器的时候，默认它会把二进制的内容以ASCII解码，如果无法解码就显示十六进制的内容。\n 从上面的输出可以看到，如果只是存储ASCII表出现的字符，那么大部分编码表保存的结果都是一样。因为它们都需要兼容ASCII表\n不过如果我们要存储中文的时候，就不一样啦，例如存储“BEE 你好”，GBK编码会把这个字符串编码成\n1000010 1000101 1000101 100000 11000100 11100011 10111010 11000011  虽然前面的\u0026rdquo;BEE\u0026rdquo;，\u0026rdquo;空格\u0026rdquo;是一样，但是\u0026rdquo;你\u0026rdquo;和\u0026rdquo;好\u0026rdquo;这两个字符是用两个字节保存的。 可以在python3中看到：\n\u0026gt;\u0026gt;\u0026gt; '你好'.encode('gb2312') b'\\xc4\\xe3\\xba\\xc3' # c3e3-\u0026gt;你 bac3-\u0026gt;好  常见编码错误之一就是使用错误的编码保存字符串。例如使用ASCII表保存\u0026rdquo;你好\u0026rdquo;，因为ASCII表里面没有对应的字符，它不知道如何保存\n\u0026gt;\u0026gt;\u0026gt; '你好'.encode('ascii') Traceback (most recent call last): File \u0026quot;\u0026lt;stdin\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)  同理，使用ASCII解码无法解析使用GBK编码保存的二进制数据\n# decode是Python中解码的方法 \u0026gt;\u0026gt;\u0026gt; b'\\xc4\\xe3\\xba\\xc3'.decode('ascii') Traceback (most recent call last): File \u0026quot;\u0026lt;stdin\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; UnicodeDecodeError: 'ascii' codec can't decode byte 0xc4 in position 0: ordinal not in range(128) \u0026gt;\u0026gt;\u0026gt; b'\\xc4\\xe3\\xba\\xc3'.decode('gb2312') '你好'  当你使用GBK编码保存文件，而文件里面包含了中文字符，那么别人使用ASCII表就无法解码。不过，如果GBK编码的文件只存储ASCII编码出现的字符，那么解码的时候也能正确解码，因为极大多的编码都兼容了ASCII编码。 其实大多数编码问题都很好解决，只需要在文档的信息上面添加这是用什么编码的，打开的时候选择对应的解码就好，不过另外一个问题就比较头痛，很多国家都开始使用自己的编码，例如日本使用Shift JIS，韩国使用KS X 1001。而且即使是中文，还有繁体中文，简体中文，编码经过发展也有几个不同版本。这样下去就越来越乱了，即使你知道文档里面存的是中文，也不知道用哪个中文编码才能正确打开，当文档中没有包含编码信息的时候，计算机就会猜测是什么编码。\n\u0026gt;\u0026gt;\u0026gt; hello = \u0026quot;你好\u0026quot; \u0026gt;\u0026gt;\u0026gt; hello_gbk = hello.encode(\u0026quot;gb2312\u0026quot;) \u0026gt;\u0026gt;\u0026gt; hello_gbk b'\\xc4\\xe3\\xba\\xc3' \u0026gt;\u0026gt;\u0026gt; hello_gbk.decode(\u0026quot;Shift-JIS\u0026quot;) 'ﾄ羲ﾃ' \u0026gt;\u0026gt;\u0026gt; hello_gbk.decode('ascii') Traceback (most recent call last): File \u0026quot;\u0026lt;stdin\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; UnicodeDecodeError: 'ascii' codec can't decode byte 0xc4 in position 0: ordinal not in range(128)  \u0026ldquo;你好\u0026rdquo;经过GBK编码变成4个字节，从这4个字节，计算机无法知道它原本是什么编码的，它尝试用用日本的Shift JIS编码来解码，这个情况下没有报错，因为Shift JIS中刚好有这4个字节对应的字符串。如果我们用ASCII表来解码，就会因为找不到对应的字符串而报错。\nUnicode编码 如果你足够聪明的话，最简单解决的方法就是，大家都用统一的表达方式，并且用足够多的二进制位来存储世界上所有字符串。这并不是痴人说梦，Unicode就是为此而生，它把每个国家的每个字符都编进去，最新的版本已经有 136,755个字符串了。例如你好，对应的是 00004F60 0000597D。不同于之前的其他编码，Unicode不是一种表现方式，只是一个标准，它规定了表现形式，至于如何编码和解码则根据不同的方式，这是什么意思呢？\nUnicode中把每个字符串都定义了对应的表现形式，一般每个字符串用4个字节表示：\n00000042 00000045 00000045 00004f60 0000597d (BEE你好) Unicode特别的地方，它只指定了表示形式，而存储形式则可以根据需要而选择，如果根据我们之前的方法，直接保存他们对应的二进制，那么就称为UTF-32编码。很直观，既然能用4个字节表达所有字符串了，这没有任何技术上的问题，而且也运行得不错。如果大家都使用UTF-32进行编码和解码的话其实就已经解决我们上面的问题了。  UTF-8编码 新的问题其实是传输量的问题，原本用传输\u0026rdquo;A\u0026rdquo;这个字符串，使用UTF-32编码的话需要用4个字节。而使用ASCII则只需要一个字节，如果日常生活只需要用英文，加上以前的存储空间非常贵，网络传输速度也慢。西方的国家存储或者传输中平白无故增加三倍的存储量当然不划算。UTF-8其实算是UTF-32的一种改进方式，把常用的字符（例如英文字符）用一个字节来表示（其实就是用了ASCII编码），不常用的用两个字节表示，更不常用的用三个或者四个字节来表示。\n   character encoding bits     A ASCII 01000001   A UTF-8 01000001   A UTF-32 00000000 00000000 00000000 01000001   你 UTF-8 10011110 01100000   你 UTF-32 00000000 00000000 10011110 01100000    HTML实体编码 URL编码 常见问题 了解编码之后，python2的编码问题其实也容易理解了。python2是把字符串直接经过utf-8编码保存的\n# utf-8编码 \u0026gt;\u0026gt;\u0026gt; \u0026quot;你好\u0026quot; '\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd'  打印出来的就是\u0026rdquo;你好\u0026rdquo;的utf-8编码的16进制(e4bda0-\u0026gt;你 e5a5bd-\u0026gt;好)\n# 获得unicode编码 \u0026gt;\u0026gt;\u0026gt; '你好'.decode('utf-8') u'\\u4f60\\u597d'  使用ASCII解码就无法解析使用utf-8编码保存的\u0026rdquo;你好\u0026rdquo;\n\u0026gt;\u0026gt;\u0026gt; '你好'.decode('ascii') Traceback (most recent call last): File \u0026quot;\u0026lt;stdin\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)  进行字符串相加的时候要注意，非ASCII编码的字符，unicode编码和utf-8编码不能直接相加\n\u0026gt;\u0026gt;\u0026gt; u'你好' + '费曼' Traceback (most recent call last): File \u0026quot;\u0026lt;stdin\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; UnicodeDecodeError: 'ascii' codec can't decode byte 0xe8 in position 0: ordinal not in range(128) \u0026gt;\u0026gt;\u0026gt; u'hello ' + 'world' u'hello world'  总结 UTF-8编码是现在标准的解决方案，当遇到乱码或者编码出错的时候，先想想原本数据是用什么编码存储的，然后使用对应的方式解码就好。单纯从二进制数据是无法判断它是用什么编码存储的。\n"
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/ping%E5%91%BD%E4%BB%A4/",
	"title": "Ping命令",
	"tags": [],
	"description": "",
	"content": " 作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处 (www.enginego.org)。\n 基础版 进阶版  基础版 什么是ping命令 有时候当我们无法上网，会计算机的朋友会说，你ping一下网关，或者你ping一个网站看看。ping这个命令，其实是操作系统自带的命令之一，如果在终端中输入：\nping www.enginggo.org  正常的话会返回：\n64 bytes from 104.24.121.11: icmp_seq=0 ttl=54 time=170.383 ms 64 bytes from 104.24.121.11: icmp_seq=1 ttl=54 time=170.053 ms 64 bytes from 104.24.121.11: icmp_seq=2 ttl=54 time=171.298 ms 64 bytes from 104.24.121.11: icmp_seq=3 ttl=54 time=170.352 ms 64 bytes from 104.24.121.11: icmp_seq=4 ttl=54 time=170.636 ms ...  从我的计算机发送64个字节的数据到104.24.121.11 (这个是经过DNS查询后的www.enginego.org的ip地址)，从发送到接受对方返回总共经过了170.xxx毫秒。代表www.enginego.org对应的那台服务器是开启并且响应ping指令的。\n如果返回：\nPING www.enginego.org (104.24.121.11): 56 data bytes Request timeout for icmp_seq 0 Request timeout for icmp_seq 1 Request timeout for icmp_seq 2 Request timeout for icmp_seq 3  这就代表连接超时，访问失败。原因有可能是本地计算机网络问题，也有可能是对应的服务器关闭或者不响应ping指令。\n如何网络诊断 当我们要连接互联网的时候，无论使用手机还是计算机，一般都要经过网关 (路由器或者交换机)，网关接受到请求包的时候经过NAT转换再连接到互联网。通常的网络诊断流程。\n 确认计算机到路由器的连接是否正常\n ping 192.168.1.1 (路由器/交换机地址)  超时则代表：\n 网线没有连接好或者 IP地址冲突  确认路由器到互联网的连接是否正常\n ping www.apple.com (网站地址)  超时则代表：\n 路由器设置出错 DNS解析出错 服务器关闭或者不响应ping指令   我们可以从这两步判断网络到底哪里出现了问题\n进阶版 ping指令实际是如何实现的 ping指令使用的是ICMP协议，就像我们每天在用的HTTP协议，客户端（我们的ping程序）根据约定好的协议规则发送二进制数据到服务器，然后服务器根据协议规则解析二进制数据中的设置与数据。 数据里面会指定使用第几个版本，发送请求的IP地址，接受请求的地址等等，如果大家对wireshark有了解，可以尝试打开wireshark之后再执行ping指令，然后查找ICMP协议对应的数据传输。\n当我使用计算机运行（这里出于方便显示把传输的数据转换成十六进制）\nping www.enginggo.org  实际发送的数据是：\n0000 b0 7f b9 a3 68 36 98 e0 d9 9d a3 8f 08 00 45 00 0010 00 54 69 21 00 00 40 01 6f 64 c0 a8 01 58 68 18 0020 78 0b 08 00 47 00 62 90 00 03 5a a1 2a fa 00 06 0030 dd c7 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 0040 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 0050 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 0060 36 37  可以看到数据中包含了发送的类别，校验和，发送程序的进程编号，IP地址等等，例如\n c0 a8 01 58对应着10进制的192 168 1 88，也就是我的计算机的IP地址\n 注意ping指令是不需要指定端口的，它是根据协议头部信息纪录的进程编号来辨识返回的数据的。\n"
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%85%AC%E7%A7%81%E9%92%A5/",
	"title": "公私钥（未完成）",
	"tags": [],
	"description": "",
	"content": "作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处（www.enginego.org）。\n我接触到很多开发者对于公钥和私钥只是一知半解，其实它的原理非常简单。\n我们一般认识的密码／密钥类似保险柜，你设置密码成0335，那么打开的密码也是0335，这种叫做对称密钥，也就是开锁和关锁用的是同一个密码。另外一种关闭的密码与打开的密码不同，叫做非对称密钥。在网络传输中，如果你要和其他人传输一段重要的信息，例如你最怕的蔬菜的名字。你想要加密传输，那么你可以把这段信息通过密钥加密，例如你要传输的是\n芹菜，苦瓜，香菜  "
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AFor%E5%90%8E%E7%AB%AF/",
	"title": "前端or后端（未完成）",
	"tags": [],
	"description": "",
	"content": "作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处（www.enginego.org）。\n"
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9/",
	"title": "编程语言选择（未完成）",
	"tags": [],
	"description": "",
	"content": " 作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处 (www.enginego.org)。\n刚开始学习编程的时候，我也很困惑这个问题，有那么那么多的编程语言，常见的有\n python ruby php Go c java R \u0026hellip;  我们可以根据你的职业职业规划来选择要学习的语言：\n前端工程师  完成设计 后端交互  前端工程师主要的职责是把设计师的设计图实现，当设计师设计完界面之后\n![design]()\n完成设计 前端工程师需要用代码来实现设计图，例如界面的布局，按钮的颜色等等。这期间需要和设计师合作交流，讨论哪些方面在工程实现中可能会有困难，可能影响性能这类的因素。\n后端交互 完成设计之后，前端工程师需要根据不同的页面以及业务逻辑来与后端交互，这句话什么意思呢？假如你开发的是一个让用户写日记的应用。那么当用户写完日记之后，点击保存按钮，这个按钮要触发一个保存日记的事件，需要把日记根据协议传输到服务器，然后存储在数据库里面。听起来有点复杂，其实非常简单，因为都有通用的工具帮助你完成。\n后端工程师。  业务逻辑处理 前端交互  业务逻辑处理 前端交互 运维工程师 数据分析／机器学习工程师 "
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/dns%E6%9F%A5%E8%AF%A2/",
	"title": "DNS查询",
	"tags": [],
	"description": "",
	"content": " 作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处（www.enginego.org）。\n当你在浏览器输入www.apple.com。按下回车之后，浏览器跳到苹果的官网，把iPhoneX的介绍和图片显示出来。浏览器是如何通过www.apple.com这个域名找到iPhone的内容并且正确显示呢？第一步就要经过DNS查询。\n DNS查询 为什么要使用域名？ Q\u0026amp;A  DNS查询 DNS查询其实很好理解，生活上比较贴近的例子就像用黄页找电话号码。在我小的时候网络还在起步阶段，家家户户都要准备一本比字典还要厚的黄页来专门记载每户的电话号码。有一次我打给魏同学问作业，先从黄页的字母表翻到W，接着根据他的家庭地址猜测哪个是他家的电话（因为黄页通常都记载家长的名字），最后才能找到对应的电话号码打过去。难以置信吧，我现在回想起来也觉得。\n刚开始，互联网联网的电脑加起来才几千台。每台电脑都保存一个类似黄页的文件（称为hosts文件）。用作记载域名对应哪个IP地址。\nwww.enginego.org 104.24.120.11 www.apple.com 119.145.144.223 www.ieee.org 23.38.177.118  （每一行分别对应着域名和IP地址）\n当我们在浏览器输入域名的时候，浏览器会先查询这个hosts文件，找到对应的IP地址。然后再通过IP地址获取到服务器里面的资源，也就是iPhoneX的简介和图片。\n为什么要使用域名？  容易记忆 计算机比较擅长处理数字，但是人类就差多了，访问苹果官网要背那么多数字显然不现实。使用域名就像我们使用手机的通讯录一样，我们会为常用的电话号码添加联系人姓名，打电话的时候直接输入名字就可以拨打，不需要背电话号码。 容易扩展 早期的计算机和IP地址是一一对应的关系，但是一台计算机的性能并不能承受大量用户的请求。而一个域名可以对应多个IP地址。这样不同地区的用户就会查询到不同的IP地址，公司也能使用多台服务器来提供服务了。   不过问题随着互联网的发展慢慢显现了，小时候的黄页每年买一本，要是在一年中你更换了电话号码，其他人也就找不到你了。互联网也是，每个小时都有新的域名被注册，新的主机加入互联网，如果还只是定时更新hosts文件会出现几个问题。\n 主机数量太多了，现在已经超过10亿台设备接入互联网，每次查询的话都要从这里面查会比较慢。 大部分的网站用户根本不会上，就像大部分在黄页上的人我都不会联系。每上线一个小网站就更新全球的电脑这样显然小题大做了。那么有什么方法可以解决这个问题呢？  （很可惜，这是治标不治本的方法）\n现代的计算机DNS查询会经过这3个步骤，一旦查询到，就会返回结果，并且跳过剩下的步骤：\n 先查询浏览器有没有保留缓存 如果你之前访问过这个网站，那么浏览器会保存对应的IP地址，这样就能减少查询IP地址的时间。\n 查询本地的hosts文件 （没错，hosts文件还没有退出时代）如果hosts文件有对应的内容，例如上面的\nwww.apple.com 119.145.144.223  那么计算机就会直接使用这个IP地址 你可以看看自己电脑的hosts文件看看有没有对应的内容\nWindows c:\\windows\\system32\\drivers\\etc\\hosts macOS /etc/hosts  DNS服务器查询 当计算机在前两个方法都没有找到对应的IP地址，就会进行DNS服务器查询，它会发送一个UDP请求到最近的子域名服务器（默认是ISP运营商提供，在国内就是中国电信，中国联通，中国移动这几家），从它们中获取到IP地址。子域名服务器定时从根域名服务器中获取最新的内容域名和IP的对应关系。\n  经过这三部，我们只需要记住某个网站的域名，就能获取到该网站的IP地址了。\nQ\u0026amp;A  Q: 那么是不是破坏这13组根域名服务器就能破坏互联网的查询功能呢？例如别人如果输入苹果的域名却跳到一个其他的网站呢。\n A: 是的。很遗憾它分布在全世界各个地区，很难同时攻击它们 :D\n Q: 浏览器直接输入DNS查询到的苹果的IP地址，是不是就能访问到www.apple.com呢？\n A: 很遗憾地说，在现代的互联网，大部分情况下是不可以的。\n  "
},
{
	"uri": "https://www.enginego.org/%E5%B7%A5%E5%85%B7/docker/windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85docker%E6%95%99%E7%A8%8B/",
	"title": "Windows安装Docker教程",
	"tags": [],
	"description": "",
	"content": " 作者：Windson Yang 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\nWindows安装Docker教程 官方英文教程\n安装前须知 你的系统需满足以下几个条件，如果不满足以下要求，请参考第二节\n 确保你电脑安装了64位的Windows 10 Pro, Enterprise或者Education(1511 November update, Build 10586 or later)版本。\n 如果你的电脑安装了VirtualBox（一个虚拟机软件，默认系统没有安装）请注意，Windows的Docker版本因为需要Microsoft Hyper-V来运作，安装之后会令VirtualBox无效。\n 必须启动虚拟化（默认启动），可以在任务管理中找到这一项确保enabled\nWindows8检查\n点击开始 \u0026gt; 任务管理 \u0026gt; 性能 \u0026gt; CPU\n黄色的Virtualization为Enabled即可\nWindows7检查\n运行Microsoft® Hardware-Assisted Virtualization Detection Tool工具，然后按照步骤来检测。\n   Docker建立的容器和镜像会被计算机上面的所有用户共享，多账号的系统中要注意数据安全问题。\n 开始安装  下载Docker稳定版 双击下载文件夹中的InstallDocker.msi文件。 阅读协议内容觉得没问题之后点击接受协议（不接受将无法安装:O)，然后安装。   一般软件应该安装在非系统盘（C盘）中，这样即使以后需要重装系统，软件也不会丢失。安装路径不要包含中文）\n  输入系统管理员密码使Docker可以安装网络组件。 完成  启动Docker 安装完成后Docker会自动启动，你可以从状态栏看到Docker正在运作 验证安装成功 运行终端(cmd.exe或者PowerShell)\nPS C:\\Users\\Docker\u0026gt; docker --version Docker version 17.03.0-ce, build 60ccb22  看到Docker version提示的字样代表安装成功了\n第二节 如果不满足条件（例如你使用的是Windows7或者Windows8系统）我们需要安装另外一款工具来运行Docker\n###安装前准备 - 先确保自己的Windows系统是Windows7以上（Windows7, Windows8，Windows10都可以）的64位系统，可以通过这里确定Windows系统版本，如果不是64位的话请更新64位的系统。\n 必须启动虚拟化（默认启动），可以在任务管理中找到这一项确保enabled\nWindows8检查\n点击开始 \u0026gt; 任务管理 \u0026gt; 性能 \u0026gt; CPU\n黄色的Virtualization为Enabled即可\nWindows7检查\n运行Microsoft® Hardware-Assisted Virtualization Detection Tool工具，然后按照步骤来检测。\n  ###开始安装\n 确保自己没有运行Virtual Box（默认系统没有按照这个软件） 点击右边链接下载Docker Toolbox 下载完毕后双击安装，如果这时候系统问你是不是允许程序修改，点击Yes 默认选项直到安装完毕  ###验证安装成功\n 双击打开Docker Toolbox  点击Yes获取修改权限 然后系统会进行一些操作，你会看到以下的图片  看到这个$符号就代表启动完成，这时候在终端输入\ndocker run hello-world   然后看到：\n$ docker run hello-world Unable to find image 'hello-world:latest' locally Pulling repository hello-world 91c95931e552: Download complete a8219747be10: Download complete Status: Downloaded newer image for hello-world:latest Hello from Docker. This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker Engine CLI client contacted the Docker Engine daemon. 2. The Docker Engine daemon pulled the \u0026quot;hello-world\u0026quot; image from the Docker Hub. (Assuming it was not already locally available.) 3. The Docker Engine daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker Engine daemon streamed that output to the Docker Engine CLI client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash For more examples and ideas, visit: https://docs.docker.com/userguide/  就代表Docker已经成功安装并且可以运行啦。\n"
},
{
	"uri": "https://www.enginego.org/%E5%B7%A5%E5%85%B7/docker/macos%E5%AE%89%E8%A3%85docker%E6%95%99%E7%A8%8B/",
	"title": "macOS系统安装docker教程",
	"tags": [],
	"description": "",
	"content": "作者：Windson Yang 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n(官方英文教程)[https://docs.docker.com/toolbox/toolbox_install_mac/]\n 系统必须满足以下全部要求：  2010后的苹果电脑，支持英特尔MMU内存虚拟 10.10.3或者更新的苹果系统 从Docker1.13版本（准备推出）之后不再支持10.10版本（OS X 10.10 Yosemite） 不能安装4.3.30版本之前的VirtualBox（默认系统并没有这个软件）    下载软件Docker for macOS 双击Docker.dmg安装\n 双击应用程序中的Docker.app来启动Docker\n 系统会请求你输入密码来启动Docker，Docker需要特殊权限来安装网络组件\n 然后可以在屏幕右上角看到Docker的标志\n 可以点击这个标志浏览设置\n 如此简单就安装成功啦，可以吃点巧克力奖励下自己了。:D\n  "
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/%E5%8D%8F%E8%AE%AE/",
	"title": "协议",
	"tags": [],
	"description": "",
	"content": " 作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处（www.enginego.org）。\n计算机使用了多种多样的协议，大家接触得比较多的是HTTP, TCP/IP, FTP, ICMP等，计算机中的协议和我们现实生活中签的协议其实挺像，双方都按照协议上的约定发送和解析数据。举个例子，你和你的朋友通过短信约定明天吃饭的时间地点。信息可以是：\n 明天 上午9点 在公司等\n 即使改变文字的顺序\n 明天 在公司等吧， 上午9点\n 一般人也能理解。不过计算机不一样，你可以把计算机当成患强迫症的朋友，它会要求你发的信息一定要符合这个约定：\n日期（两个字）-\u0026gt; 时间（四个字）-\u0026gt; 地点（四个字）   明天 \u0026ndash;日期\u0026ndash; 上午9点 \u0026ndash;时间\u0026ndash; 在公司等 \u0026ndash;地点\u0026ndash;\n 只要你和朋友遵守这个约定发送和接受信息，那么你们就互相遵守了一个协议。\n这样有什么优点呢？  无论对计算机或者人类来说，信息都变得有序和容易处理。当我们知道信息遵守协议A的时候，我们不需要阅读信息都知道前两个字是日期，接着是四个字的时间，最后是四个字的地点。  举个常见的例子，当你使用浏览器访问www.apple.com，浏览器其实是按照HTTP协议的约定向苹果服务器发出信息：\n第一行是请求方法和协议版本（8个字节） 第二行是请求的URL（30个字节） 第三行是连接是否持久化（30个字节） ...  实际发送的信息是：\n0000 b0 7f b9 a3 68 36 98 e0 d9 9d a3 8f 08 00 45 00 0010 02 0a 76 f9 40 00 40 06 1e d1 c0 a8 01 58 68 18 0020 79 0b fe 5b 00 50 55 fb ab bc e6 45 57 80 50 18 ...  转换成人类可读的文字就是：\nGET / HTTP/1.1\\r\\n Host: www.apple.com\\r\\n Connection: keep-alive\\r\\n Pragma: no-cache\\r\\n Cache-Control: no-cache\\r\\n Upgrade-Insecure-Requests: 1\\r\\n User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\\r\\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n DNT: 1\\r\\n Accept-Encoding: gzip, deflate, br\\r\\n Accept-Language: en,zh;q=0.9,en-US;q=0.8,zh-CN;q=0.7\\r\\n  在HTTP协议里面这些信息统称为HTTP的请求头部（每行最后的\\r\\n是换行符，服务器读取到\\r\\n就知道接下来的内容是下一行）。它们大多有固定的选项，服务器拿到这条信息之后就可以直接对照协议的顺序来返回数据。想了解更多的朋友可以参考An overview of HTTP\nAPI和协议有什么关系 有时候工程师也会称API为协议，当一组API非常有名，例如HTTP，FTP，大家都知道的情况下，我们可以称它为协议。另外API一般是给另外一方调用的，例如你开发了一款照片上传的软件，可以让用户上传图片，保存自己与家人的回忆。开发完之后，有很多用户希望加上美颜的功能，你想了，自己开发这些功能需要花很多时间，能不能使用其他软件的美颜的代码呢？这时候，如果EngineGo写了一套美颜的算法，他提供一个外部API（也可以称为接口），使用这个接口和协议类似：\n这个API使用HTTP协议 第一行是图片 第二行是美颜级别 第三行是https://www.enginego.org/image/  你不需要知道EnginGo如何实现滤镜和美颜的功能，他只需要把图片发送到这个URL地址，服务器就会返回一张美颜过的图片给你，你就可以把这张图片展示给用户了。简单来说，API就是接受输入（图片，美颜等级，URL地址）返回结果（美颜后的图片）的模块。\n"
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/%E5%9F%9F%E5%90%8D/",
	"title": "域名",
	"tags": [],
	"description": "",
	"content": "作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处（www.enginego.org）。\n计算机知识往往互相关联，要真正了解域名是什么，必须先了解什么是URI。这里有一些常见的例子。\nhttps://www.apple.com http://www.w3c.org ftp://example.org/resource.txt file:///Users/example/hello.jpg  最后两个大家可能不太熟悉，以最后一个为例子，你们可以尝试把自己电脑中任意的文件拖放到浏览器中，浏览器会去猜这个文件类型，一些常见的文件类型例如图片，浏览器可以判断并渲染出来。同时浏览器的地址栏也会变成file开头。这个例子中的file就是这个URI所使用的协议。常见的协议还有\nHTTP 超文本传输协议 SMTP 邮件协议 telnet 终端传输协议 DNS 域名系统协议 DHCP 动态主机配置协议  好吧，我承认部分对于一般大众不是很常见，不过如果你想认真学习编程，起码看到这些名词的时候知道是什么。感兴趣的学生可以前往Lists of network protocols。那么协议又是什么呢？其实协议的本质非常简单。\n域名（Domain names）是互联网基础架构的关键部分。它们为互联网上任何可用的网页服务器提供了人类可读的地址。 任何连上互联网的电脑都可以通过一个公共IP地址访问到，对于IPv4来说，这个地址由32位组成（它们通常写成四个范围在0~255以内，由点分隔的数字组成，比如173.194.121.32），而对于IPv6来说，这个地址由128位组成，通常写成八组由冒号分隔的四进制数(e.g., 2027:0da8:8b73:0000:0000:8a2e:0370:1337).  "
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/%E6%9C%8D%E5%8A%A1%E7%AB%AF/",
	"title": "基础术语",
	"tags": [],
	"description": "",
	"content": " 作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n服务端 很简单，服务器就是一台**24小时运行**，运行着**专为服务器设计的系统**的**高性能计算机**。它也是由内存，硬盘，CPU组成。不过它会根据这台服务器的用途来配置不同的组件。有些服务器专门用来存储文件，图片，那么它就需要更大的硬盘，对CPU的要求就没那么高。有些专门用来进行高密度的计算，例如视频转格式，数据分析那么就要更快的CPU。 服务器会根据不同客户端的请求返回不同的内容，当你使用浏览器访问一个页面的时候，实际上浏览器就是寻找该页面对应的服务器获取相应的图片和文字内容。  客户端 常见的客户端包括浏览器，手机，它请求服务器需要的资源，然后客户端解析返回的内容并且显示给用户。  "
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/%E7%BB%88%E7%AB%AF/",
	"title": "终端",
	"tags": [],
	"description": "",
	"content": " 作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处 (www.enginego.org)。\n使用终端是我们开始编程的第一步，无论是运行程序，或者了解计算机的基本信息都需要用到。让我们愉快地和它玩耍把。\n 基础版 进阶版  基础版  什么是终端 为什么要用终端  什么是终端  图形界面 命令行界面 亲自试试吧  图形界面 我们平时习惯了使用图形界面，当我们双击图标打开文件，计算机会先通过后续去猜测用什么程序运行文件，如果是图片(.jpg, .png)的话，计算机就会用图片浏览器打开，如果是可执行文件(macOS下的dmg后缀文件，Windows下的exe后缀文件)，计算机会先找到该应用的在硬盘中的位置，然后根据可执行文件里面包含的信息（需要加载什么资源）来运行程序。\n命令行界面 在计算机刚开始发展的时候，并没有那么容易上手的操作界面，大家都是通过一个黑乎乎的程序输入命令，然后等待计算机执行。\n这时候运行程序或者打开文件，则需要使用不同的命令。例如打开一个名为normal.txt的文本文件，可以用cat命令：\ncat normal.txt  要打开图片的话，需要安装额外的软件来打开。要运行一个名为hello.py的python程序，在安装了python软件之后，在终端直接输入\npython hello.py  回车之后就可以看到程序的输出结果了。其实图形界面与命令行界面运行的本质是一样的，运行程序或者打开文件：\n 安装对应的软件 指定程序运行 (图形界面会根据后缀名帮你选择用什么程序来打开。)  亲自试试吧 你可以尝试先打开自己计算机的终端：\n macOS: 同时按住\u0026rdquo;control\u0026rdquo;+\u0026ldquo;space\u0026rdquo;键，在搜索框输入termianl，\u0026rdquo;回车\u0026rdquo;\nWindows 7：打开\u0026rdquo;开始\u0026rdquo;菜单，在搜索框里输入cmd，\u0026rdquo;回车\u0026rdquo;\nWindows 8+：同时按住\u0026rdquo;win\u0026rdquo;+\u0026ldquo;Q\u0026rdquo;键，然后在弹出的搜索框里输入cmd，\u0026rdquo;回车\u0026rdquo;\n 成功打开之后，光标会停留在某一行。类似：\nWindsondeMacBook-Air:~ windson$ |  因为和计算机交互需要遵守一定的指令规则，终端默认会运行一个程序，常见的是Bash(Bourne Again SHell)或者sh，你可以尝试输入一个命令，然后让终端执行。\n macOS: \u0026ldquo;ls\u0026rdquo;+\u0026ldquo;回车\u0026rdquo;\nWindows: \u0026ldquo;dir\u0026rdquo;+\u0026ldquo;回车\u0026rdquo;\n 输入回车之后，你会发现终端显示出了一些文字，仔细观察的话你会发现其实是你电脑中某个目录下的文件。ls/dir这个命令就是列出当前目录的文件。 当然这个命令还有很多参数，也就是你可以告诉计算机显示什么文件（隐藏／非隐藏），显示文件的详细内容（创建日期，大小），ls/dir只会调用一个常用的默认配置，假如你想把隐藏文件也显示的话，在终端输入\n macOS: \u0026ldquo;ls -a\u0026rdquo;+\u0026ldquo;回车\u0026rdquo;\nWindows: \u0026ldquo;dir -a\u0026rdquo;+\u0026ldquo;回车\u0026rdquo;\n 终端还有很多其他命令，例如ping命令可以用作网络诊断。\nping www.apple.com 64 bytes from 27.148.139.136: icmp_seq=0 ttl=54 time=21.056 ms 64 bytes from 27.148.139.136: icmp_seq=1 ttl=54 time=21.575 ms 64 bytes from 27.148.139.136: icmp_seq=2 ttl=54 time=20.989 ms  为什么要用终端 以前的计算机根本没有图形界面，只能对着这样黑乎乎的界面一行行输入指令，然后祈祷它不会出错。既然现在已经有图形界面了，为什么我们还需要学习用终端呢？\n 多功能，一般一个软件只会专注于一个功能，例如Word进行文字编辑，PowerPoint进行幻灯片编辑。你可以通过终端让计算机调用不同的程序完成多种多样的功能。\n 方便，对，一开始可能难以置信，但是使用终端确实比图形界面方便。你可能也会曾经遇过某一款软件更新，你找不到原本功能的按钮在哪里了。（例如某段时间Windows系统就把把“开始”菜单隐藏了。）使用命令（例如上面的ls/dir）的话即使系统如何更新都能显示当前目录的文件。\n 速度快，效率高。当你要连接远程的服务器的时候，如果连接的是图形界面，那么由于网络原因以及机器性能的影响，通常都会卡得一塌糊涂。不过如果只连接命令行界面的话，那么对于网络以及机器的性能要求就非常低，能够极大地提高工作效率。\n 高效，跨平台，跨机器，假如今天你要清理电脑，要删除一个大型文件夹中（可能包含子文件夹）超过90天之前创建的所有文件，一般来说的话你需要一个个文件夹找，然后对每个文件夹里的文件进行时间排序，再手动删除超过90天的，如果里面包含了100个文件夹那么会费很多时间，同时也容易出错。使用终端的话可以直接运行\nfind /path/to/base/dir/* -type f -ctime +90 -delete  而且只要跑同一个系统就不用担心命令会执行出错。\n 容易定制，使用指令的好处是很容易根据需求来修改，加入想删除的是所有超过90天之前创建的文件夹，只需要修改\u0026rsquo;-type f\u0026rsquo;为\u0026rsquo;-type d\u0026rsquo;即可，这里type代表的是指令针对什么类型操作，f是files，d这是directory。\n  当然，要学会基本的指令也要花时间，例如一个find指令就有超过50个参数（这个命令比较特殊，参数比较多，我也常不记得，想用的时候搜索一下就好）。\n如果你使用对的是Windows系统请注意，Windows有自己的一套特殊指令, 我不建议大家使用Windows来学习编程，相对来说macOX与Linux系统对开发者（也就是你）更加友好，使用他们会节约你很多时间。 不过这不代表你需要额外买一台电脑才能学习编程，只需要安装双系统或者虚拟系统就好，如果你没有接触过，没关系。我们会一步步介绍，你可以先在Windows中安装Docker，然后就可以在Windows系统中使用Linux了。\n进阶版 Bash是如何实现的 "
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/%E8%B7%AF%E5%BE%84/",
	"title": "路径",
	"tags": [],
	"description": "",
	"content": " 作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处（www.enginego.org）。\n 绝对路径和相对路径 当前路径 切换路径  绝对路径和相对路径 . └── usr ├── foo │ ├── first.md │ └── second.md ├── bar │ ├── sunkist.toml │ ├── cherry.toml  计算机文件的存放结构如上图一样，上图中，usr文件夹中包含了foo和bar两个文件夹，这两个文件夹分别包含了两个文件。路径指的是为文件/文件夹存放在计算机中的位置。举个现实的例子：\n有一天，Cherry在路上遇到Sunkist，它问Sunkist的公司地址在哪里，Sunkist可能有两个答案：\n 以这里为起点，西南方向500米的石室大厦 中国广东省广州市思哲路石室大厦  第一个答案以当前的位置为起点所描述的称为相对路径。第二个答案从国家到省份城市巨细无遗地描述称为绝对路径。根据Sunkist当前的位置不一样，它回答的相对路径会不一样，但是绝对路径是不会变化的。每个文件/文件夹在一台计算机中可能会有无数个相对路径，但是只有一个绝对路径。上图中，first.md的绝对路径是\n/usr/foo/first.md (first.md的绝对路径)  相对foo目录的路径是\n./first.md (相对foo目录的路径)  相对bar目录的相对路径是\n../foo/first.md (相对bar目录的路径)  在路径命令中\u0026rdquo;.\u0026ldquo;以及\u0026rdquo;..\u0026ldquo;这两个符号有特殊意义，分别代表当前目录以及上一级目录。如果当前路径是\u0026rdquo;/usr/foo/\u0026rdquo;\n/usr/foo/ (当前路径) ./ = /usr/foo/ (当前目录) ../ = /usr/ (上一级目录)  所以\n./first.md  表示的是当前目录下的first.md文件(first.md原本就在foo目录里面)\n../foo/first.md  表示的是先返回当前目录(/usr/bar/)的上一级目录(/usr/)，然后再进入foo目录，找到first.md文件\n当前路径 当你打开终端的时候：\n(masOS) WindsondeMacBook-Air:fun/ windson$ (Windsons) C:fun\\:  这里的\u0026rdquo;fun/\u0026ldquo;和\u0026rdquo;C:fun\\\u0026ldquo;指当前执行命令的地方，也就是你的当前路径。可以通过命令来查看当前路径的绝对路径\n(masOS) WindsondeMacBook-Air:foo/ windson$ pwd /usr/foo/ (Windsons) C:foo\\: cd \\usr\\foo\\  当你在终端中输入命令，默认针对的就是当前路径。例如输入\u0026rdquo;ls\u0026rdquo;，计算机会理解成\u0026rdquo;ls /usr/foo/\u0026ldquo;(输入\u0026rdquo;dir\u0026rdquo;，理解为\u0026rdquo;dir \\usr\\foo\\\u0026ldquo;)，两个命令都会列出当前路径中\u0026rdquo;foo/\u0026ldquo;下面的所有文件名称。\n切换路径 那么当你从一个目录，如何跳转到其他目录呢？我们可以使用系统自带的\u0026rdquo;cd\u0026rdquo;命令。\ncd [PATH] . └── usr ├── foo │ ├── first.md │ └── second.md ├── bar │ ├── sunkist.toml │ ├── cherry.toml  这里的path可以是绝对路径或者相对路径，如果你要从\u0026rdquo;/usr/foo/\u0026ldquo;跳转到\u0026rdquo;/usr/bar/\u0026ldquo;，你可以使用：\ncd /usr/bar/ 或者 cd ../bar/  总结 大家了解了路径的基础知识，之后学习环境变量就会很容易理解啦。\n"
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/hook/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/%E5%86%85%E5%AD%98/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/%E5%A0%86%E6%A0%88/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/%E5%B5%8C%E5%A5%97%E5%AD%97/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/%E6%8A%93%E5%8C%85/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E6%9C%AF%E8%AF%AD/%E8%BF%9B%E7%A8%8B/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.enginego.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.enginego.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.enginego.org/%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/",
	"title": "如何准备技术面试",
	"tags": [],
	"description": "",
	"content": " 作者：Windson Yang\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处（www.enginego.org）。\n我刚工作的时候，对面试总是很恐惧，一方面怕简历无法通过筛选，另一方面怕现场发挥得不好，浪费了自己和面试官的时间。我当初并不知道对比其他求职者，自己的优势和劣势在哪里，也不知道自己到底值多少钱。 面试的时候都觉得面试官很严肃，问的问题我也都答不上，肯定没有机会入职，觉得自己烂透了，也不想浪费时间去面试多几家了。\n现在回过头看，我觉得当初自己在欺骗自己，我真正担心的是即使自己认真准备简历和面试也对结果毫无影响，更不敢去想如果找不到工作没钱缴房租怎么办，索性海投简历碰运气。其实认真准备简历和面试是很有用的，因为毫无准备，随便面试的求职者真的太多了。 工作了几年，我作为面试官筛选过千份简历，面试过不下100名工程师。我慢慢发现，招聘真的是一件非常难的事。招的人要有计算机基础知识，有项目经验，愿意学习而且愿意来这家公司。所以只要你有一定的实力，现在的互联网行业还是买方市场，认真准备总是有收获的。我希望把这几年作为面试者和面试官身份的的经验給大家，希望大家可以学到从中一些面试的技巧，找到心仪的工作。\n 分析阶段 准备阶段 面试阶段 总结阶段  分析阶段  公司需要怎样的员工 员工需要怎样的公司 了解自己的优势  公司需要怎样的员工 先从公司的角度出发，如果你是部门的总监，你会希望什么样的员工？\n我很喜欢Google前CEO施密特分享的一个故事，他刚到Google的时候，Google还只是个小的创业公司。他以为Google和其他公司没什么两样，直到有一个周五，拉里佩奇在用谷歌搜索一些关键字的时候，他发现出现了一些不相干的广告推荐（这个情况我们现在在国内最大的搜索引擎也经常看到）。施密特以为接下来就是开几个会议，然后分到具体的工程师手上解决。但是拉里佩奇没有这么做，他用纸条写下\u0026rdquo;These Ads Suck!\u0026ldquo;，附上相关的截图贴在布告栏上就回家了。接下来的72小时彻底改变了施密特的认知。在周一凌晨5点，有几位并不是负责广告业务的工程师发来一份邮件，从头到尾阐述了这个问题产生的原因，他们的解决方案，以及这个计划对公司有什么影响。这和我们强制的996加班不一样，他们从公司的角度去思考，自愿自发地用周末的时间去解决并不属于自己范畴的问题。 这样的员工我想就是每个公司都需要的：\n 刻苦耐劳，能及时解决问题 愿意自我学习，自我增值 团队精神，愿意帮助他人 对公司忠诚  所以求职者的简历，面试过程中必须能体现出这几点品质。 例如很多求职者简历提到喜欢计算机，平常花很多时间学习计算机，但是又给不出详细的答案，这样要不就是他们只是三天打鱼两天晒网地学习，要不就是没有认真思考这个问题。从简历的角度，与其写：\n 热爱计算机，喜欢学习计算机系统的知识。\n 建议修改为：\n 喜欢阅读计算机系统的书籍，完成《深入理解计算机系统》90%以上的习题。有自己的博客文章系列分享学到的知识。\n 如果你是面试官，你会选哪位呢？前一类基本三分之一的简历都有这类的描述，后一类呢？百中无一。\n员工需要怎样的公司 找新工作之前，先认真思考下几个问题，一份工作中你最看重的是哪些方面？\n 薪酬 公司福利／工作环境 工作方向（假如你要从技术转向管理，这个岗位提供这样的可能吗？) 公司发展前景 个人成长 其他  了解自己的想法之后，再进行筛选公司以及准备如何提问。我认为薪酬的重要程度远远不及公司文化，如果公司文化好，吸引到厉害的工程师。你认真待着一两年，进步速度要快得多。你可以根据自己的着重点，筛选不同的公司，以及准备向面试官提问的问题。 这点我们在面试阶段会介绍，提问这部分非常重要，我遇见很多求职者感觉不好意思提问，一方面怕面试官会觉得自己有很多要求，另一方面根本没有想好要问什么。这点我觉得非常不明智，公司和员工就是互相选择的，一定要多提问题，了解公司的文化以及岗位的职责。才不至于刚入职就因为不适应而要离开。如果求职者没有提问，面试官也会担心求职者入职后会不会不适应公司的某些规定，例如加班规定，着装要求。由于解雇一位员工比招聘要痛苦得多，面试官反而会不敢轻易录用他。\n了解自己的优势 仔细分析自己的优势和劣势是什么，然后添加在简历中，优势可以从这几点入手，后面是面试官的理解：\n优势\n 大型项目的经验 （能解决项目普遍出现的问题，代码能力应该不会差。） 作为主要参与者得过奖项 (聪明，勇于尝试） 维护优秀的开源项目 (懂得团队协作，能写出优秀的代码） 发表过论文或者优秀的博客文章 (研究能力强，分析能力强） 数据结构和算法基础好，Leetcode中等难度都能bug free（基础不错，培养起来也简单） 思维敏捷，聪明，有想法 （需要有文章，论文，得奖来证明） 毕业于不错的学校 (学习努力）  与上面相反的就是劣势了。了解到自己的优势和劣势，简历就可以强调自己的优势，然后根据自己的劣势来准备。例如，如果你要面试的是一家公司的CTO，那么大型项目的经验可能就比较重要，如果面试的是研究岗位，那么论文与文章的数量就比较重要。\n准备阶段  随时都在准备 技术知识 积累项目经验 准备简历 模拟面试 选择公司  随时都在准备 随时准备并不是鼓励频繁地跳槽，而是要有随时有跳出舒服圈的准备，也许你已经很满意现在的工作，薪酬，觉得习惯而且安逸。不过如果公司突然倒闭，或者部门被裁减，你还能找到这样或者更好的工作吗？我建议各位求职者，每半年可以去面试几家公司，因为你已经有不错的工作了，所以可以带着轻松的心态去面试，每一次面试都是很好的磨练机会。 面试就像打篮球投球一样，多练习才会准，如果一直害怕不进，连投球都不投的话，那连碰运气的机会也没有了。我刚参加工作的时候是一份烂透的简历\u0026mdash;普通大学，专业不是计算机，作品也没多少。也有一间大公司给我面试的机会。（我没有做好准备，所以第一次的时候失败了，第二次成功入职了。后来我知道互联网行业招人真的非常难。)。机会随时都会来，如果明天你喜欢的公司让你去面试，你准备好了吗？当你的GitHub看起来不错的时候，很多公司的HR就会邮件联系你。你有信心去面试吗？工作空闲之余看看优秀的博客，研究下算法题，日积月累下来基础就会越来越牢固。\n技术知识 计算机科学基础\n 操作系统基础 网络协议基础 数据结构与算法基础 堆栈，链表，队列，二叉树，哈希表，图以及对应常用的操作方法 二分法，位操作，递归，动态规划 七大排序算法  系统设计\n 缓存，分布式存储/计算 设计模式 数据库基础  我推荐几个学习资源：\n Cracking the Coding Interview tech-interview-handbook Leetcode  刷算法题的时候，要把每道题都当成面试题一样按步骤完成，完成一题之后总结经验。这样遇到变形题也迎刃而解。 你可能有个疑问，觉得这些平常工作都用不到。其实不是的，第一，平常工作都能用到，从最简单的二分查找到复杂一点的native bayes. 开发的过程中可能因为你不了解不知道这个算法，所以一开始没有选择这个算法／数据结构。 第二，数据结构和算法锻炼的是思维，当你刷算法题例如leetcode的时候，慢慢会学习到一些有趣的，巧妙的方法。它们能扩展你的编程时思考的范围。同时也要求你考虑到各种不同的边界情况。即使你不准备换工作，我也建议每天都刷一道算法题，日积月累，一年下来你的算法基础一定能比同龄人高出不少。而且当你真正理解算法题的知识之后，写程序debug和花在stackoverflow的时间就会大大减少，往往知道哪里可能有问题并且能大幅地增加工作效率。\n积累项目经验  参与开源项目  计算机科学最重要的就是实际运用，关键就是多参与，多思考。开源项目可以让你和世界上顶级的工程师一起工作，学习软件设计以及语言的高级使用方法。同时能让你理解软件的是如何运行的。\n 参与较底层／较复杂／偏向算法或研究的项目  如果你未来想从开发转向研究的岗位，那么就可以阅读一些学术论文，一些机器学习的算法。\n 造轮子，写一些实用的工具  从学习的角度来说，造轮子可以说是最好的方法，不过你要给自己一个期限，不能无止境地把时间花费在程序的细节中。知道原理，能够实现其实就非常好。尝试从实现平时常用的Web服务器，Web框架开始，有兴趣可以延展到到操作系统或者编程语言（我遇到过这样的求职者）。自己写完再看看别人是如何实现的，学习他的优点。其实到最后，你会发现计算机是越学越容易的，如果你不了解同步异步，往往是因为你不知道Web服务器是如何实现，不知道系统调用是如何实现的。当你能自己去实现的时候，很多以前的问题也就迎刃而解了。\n 写论文，分享文章  如何宣传你的开源项目或者业余项目？写一篇优秀的文章介绍它。同理，要证明你有喜欢计算机，有研究的能力，最好的方法也是写一些优秀的文章以及论文。\n准备简历  找出优势 给出证明 其他能力  我筛选过超过千份的简历，遇到太多太多千篇一律的简历了，描述都是熟练精通xxx框架，项目经验都是博客加爬虫。无论你是计算机专业，还是其他专业，还是培训班出来，都应该重视自己的简历。要知道哪些简历是“不好的简历”，这里指的不好，未必是求职者个人的问题，而是他没有从面试官的角度来思考编辑简历。几个要点是要注意的：\n找出优势 简历并不是越长越好，最好的简历长度是一到两页，列出你最优秀的项目经验以及奖项。至于语言或者框架，只是简单接触过的话就不用写上去了。面试官问你有没有学过其他的时候才说出来。假如你只是学过简单接触过Go，面试官会先入为主地以为你对这个语言比较了解，如果问一些基础的问题你也没有回答正确。这样反而会给面试官留下不好的印象，因为他会认为你对简历中的其他你真正熟练的语言也不太了解。。常规的写法可能是：\n 精通django框架，熟悉Python语言\n 建议修改为：\n 精通django框架，是django的Top50代码贡献者。熟悉Python语言，理解Python垃圾回收，迭代器，装饰器等常用对象的实现原理\n 多花几分钟的时间，就能在求职者的简历里面脱颖而出了。\n给出证明 常规写法：\n 前期负责前后端API设计，后期负责实时流消息处理应用系统构建和实现\n 面试官无法知道你做得怎么样，建议修改为：\n 经过团队讨论，使用Graphql为新的API接口规范，从而减少20%的日均请求量，并节省了两台服务器资源。后期使用RTSP协议进行实时流消息处理，请求响应时间平均为40ms，同时架构了能支持20万日活量的缓存服务器与后台服务器。\n 其实这并不是吹嘘，因为你在项目中做的每一个选择必然是有道理的，而且必然会对项目产生影响。而你要做的就是把你做的最优秀的项目中你产生最大的影响那部分讲出来。如果只是想面试官到时候有兴趣的时候问再答吧，到时候如果紧张，很容易忘记具体的数字。如果项目经验不多，可以把学校的专业排名(50\u0026frasl;1000)，员工考评(10\u0026frasl;1000)，优秀员工这些指标都加上去。不要觉得没有用，这绝对是大多数求职者忽视但是非常重要的点。 而且简历如果既有一些较新的技术（例如Rust，Go，当然你要真的了解），又有经典的必备的技能，那么就一定能够吸引他的眼球。\n其他能力 其他能力就是团队协作能力以及解决问题的能力，如果你已经在开源项目有不错的贡献，那么面试官就不用担心团队协作能力。至于解决问题的能力，你可以在项目经验中可以列出解决的比较复杂的问题，例如 \u0026ldquo;解决了服务端同时推送10万台设备的的并发与资源占用过多问题\u0026rdquo;。这样面试官就知道你既有团队协作能力又有解决难题的能力。面试题就不会出那么难了。 其实很多公司在面试的时候都会出一些非常难的题，并不要求面试者一定要解决，而是要看面试者在遇到难题的时候会怎么面对，是思考一下就放弃，是寻求面试官提示，还是从多个角度去解决问题。如果在简历中已经体现了这一点，那么面试的时候就能略微放松了。\n模拟面试 这个大家可能接触得比较少，如果你准备去面试一家非常喜欢的公司，面试之前，你应该先进行模拟面试，模拟面试既可以让你的朋友当面试官来面试你，也可以去找几个有类似岗位的公司。第一，当你本来就没有一定要进模拟公司的想法，那么心态自然就能放轻松，带着轻松的心态去面试的话更能发挥好，给自己信心，同时也可以问问面试官自己哪里不足，可以加强的。同时锻炼自己面试的技巧，包括技术的基础，以及如何问问题。当你面试得多了，发现其实都差不多，遇到问题也有经验了。平时也可以在一些在线网站上面模拟，例如Pramp。\n选择公司 前几家公司的选择对你的职业规划会有很大的影响。\n大公司  优势\n 入职薪酬比较高，每年固定调薪，员工福利例如下午茶，文娱活动，年假都有保证。 通常都有大牛，而且工程师比较多，总能遇到一些志同道合的朋友。 通常加班压力没那么大。完成份内工作即好，开发不需要部署和测试。 跳槽到小公司比较容易，岗位也能得到提升。   劣势\n 刚进去的时候接手的可能都是比较枯燥的小项目。 可能需要维护几年前的没有文档没有测试的项目。（其实也能学习到很多） 比较容易安逸，缺乏学习的动力。   小公司  优势\n 相对来说，条条框框没那么多，偶尔迟到请假没什么关系。 什么都能学到，从开发到运维到测试。 项目可以加上自己的建议和想法，比较有成就感。 能直接向老板汇报，升职速度比较快。   劣势\n 入职薪酬比较低，员工福利嘛，不能保证。 有大牛的可能比较少，除非你事先知道（所以面试问问题非常重要）。 加班压力通常比较大，而且公司不一定会根据你的加班时间就涨薪。 跳槽到大公司比较难，除非你有非常好的简历与能力。   其实选择怎样的公司往往和求职者的个人意愿有关，不过在国内来说，小公司并没有那么自由，加班也可能很多。所有我觉得一开始选择大公司往往是不错的选择，之后跳槽的选择范围也更多。\n面试阶段  HR电话确认 电话面试 家庭作业 现场面试 非技术问题 求职者提问  当你得到了面试的机会，开始进入重头戏了，无论你的履历如何出众，都不能对面试掉以轻心。我遇过很多简历不错但是面试一塌糊涂的求职者，结果当然没有录用他们。翻转二叉树起码要会写吧 :D 面试一般会有几轮：\nHR电话确认 HR会和你聊下天，确保你了解这个岗位的基本信息。也可能问几个关于你简历的问题，这轮只是考核下你的基础信息是否正确，看看你的谈吐是否正常（相信我，很多求职者如果不看自己的简历，连自我介绍都做不到）这轮放轻松，实话实话就好。\n电话面试 这是技术面试的第一轮，可能会电话提问，也可能是通过把题目发在在线文档，然后让你去解决。一般都是比较简单的算法，数据结构的基础问题。如果遇到难的也不需要担心，提供一些解题的思路，即使最后不能bugfree，起码也有一些头绪。\n家庭作业 这轮并不常见，有的公司会让你实现一个小模块或者小工具。主要考核你实际情况下的开发能力。这点就要靠平时积累了，如何设计API，使用什么设计模式，都有讲究。多看开源项目源码就好。Python的话我推荐看Requests源码\n现场面试  提问 测试用例 思考 阐述 伪代码 代码 检查  现场面试可能会有简单的面试题，然后面试官出几道算法题让你可能电脑实操，也可能写在白纸或者白板上。我明白很多求职者不喜欢白板面试，也觉得白板面试没什么意义。不过在我面试的求职者中，白板面试能力强的在实际工作中表现得也比较优异。白板面试确实难，不但对于你，对于其他求职者也是。要是你能做到，别人做不到，你就能在众多求职者中突围而出。 简述一下解算法题的几个步骤：\n出个经典题目Two Sum：\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.\n 给出一个整数数组和一个目标数，返回两个索引值，它们对应的数组元素的和等于目标数，只有一个答案。\n Example:\nGiven nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].  提问 这阶段的提问非常重要，因为你要100%地清晰地了解题目，才能解决题目。不要觉得提问得多显得愚蠢，提问得多代表你在思考，没有问题我反而会担心求职者是不是之前做过这题，或者根本没有思路。\n 这是一个有序数组吗？ 不是 可以包含负数吗？ 不可以 如果数组为空或者只包含一个数字，是没有答案吗？对的 时间复杂度和空间复杂度有限制吗？没有  题目就转变成\n 一个只包含正整数的有序数组，返回两个不同的数组索引值，它们对应的数组元素的和正好等于目标数，如果数组为空或者只包含一个数字的话没有答案，其他情况只有一个答案。\n 这样就能排除一些边界情况了。然后写测试用例\n测试用例 target = 1 [], [1], [1, 1], [1, 1, 1], [1, 2, 1], [1, 2, 3], [5, 4, 2]  空的，只有一个元素，重复元素，正序，逆序，正常情况都写下来，面试官会对你考虑到那么多情况而加分。\n思考 先想想会用什么数据结构，链表，哈希表，堆，栈，二叉树，哪个结构能解决这个问题？如果没有思路的话，可以请面试官给点提示，这个其实也是团队合作的一种表现，请求提示不一定面试官就觉得你能力不行。\n阐述 边思考边向面试官说出你的思路，虽然你的思路可能比较乱，没什么章节。但是没关系。要大声肯定地说出自己的想法，同时可以向面试官提问。我面试过几位求职者，虽然他们没有顺利地完成算法题，但是能一直说出自己的思路，给我留下不错的印象。就像我之前说的，有些难题，面试官并不是期望你都能答对，只不过想知道你遇到难题是如何解决的。所以阐述自己的想法是非常重要的。\n伪代码 如果数组长度小于2，返回False 建立一个哈希表 遍历数组每一个元素： 如果目标值减去元素值在哈希表中 返回该索引与当前索引 否则把当前索引与值添加到哈希表中\n时间复杂度为O(n)，空间复杂度为O(n)\n代码 这题算简单：\nclass Solution(object): def twoSum(self, nums, target): # 如果数组长度少于2的话，无解 if len(nums) \u0026lt;= 1: return False tem_dict = {} for i in range(len(nums)): # 检测这个元素是否曾经出现过 if nums[i] in tem_dict: return [tem_dict[nums[i]], i] else: tem_dict[target - nums[i]] = i  检查 把测试用例带进去，然后看看哪里可能会有问题，做出修改。\n非技术问题 接下来面试官可能会问一些非技术的问题：\n Q: 为什么选择这家公司？ A: 面试之前对起码要浏览过公司的网站，了解公司有什么产品，这样既可以防止遇到皮包公司，或者小作坊欠薪拖薪。也可以真正地去想你到底喜不喜欢这家公司，面试和找男女朋友一样，找你喜欢的，而不是找你能找到的。 回答可以说说你对这个公司的印象。\n Q: 你曾经面临最大的专业挑战是什么？你是怎么战胜它的？\n A: 这个一定要准备好，不能说没什么挑战，没什么挑战代表你没有认真去思考，就算是最简单的增删改查或者前端的动效，背后的原理，网络协议的原理，你都应该去了解。选出一个你钻研地比较深的点分享。\n Q: 是什么为什么你选择离开你现任公司？你从你上一家公司学到最重要的是什么？\n A: 大多数求职者不喜欢这个问题，也不知道怎么回答。这个问题你能回答好的话就能拉出距离了。我觉得答案其实很简单，你们公司的项目有更好的发展前景／我想挑战自己在这一方面的能力等等。至于说旧公司薪酬太低，工时太长，没前途这些就免了。\n Q: 你的长期工作目标是什么？\n A: 这个看个人，转管理的话可能会加一轮问管理方面的问题，转资深工程师的话可以讲下自己打算钻研哪个方向，大数据，人工智能，区块链都可以。\n  求职者提问 这点非常重要，要预防你到了新公司之后，发现公司文化不适合你，再马上找新工作的话就不好了。\n Q: 你们新老员工的比例是多少？厉害的工程师有多少？ A: 这个问题其实揭示了公司的文化，如果新员工非常多，公司也不算新的话，那么代表流动率很高，公司文化可能不是很好。第二个问题其实就是问有没有大牛，有多少。有厉害的工程师总比没有要好得多，进步的速度也更快。一个公司如果有比较多优秀的工程师的话，代表是不错的公司。\n Q: 如果我入职的话，会有入职培训吗？会被分到哪个项目组，项目组的成员构成是怎样？\n A: 这个可以了解公司的架构是不是清晰，个人职责划分是否明确。如果面试官回答不了这个问题，或者支支吾吾的话。即使你进去的话可能要兼顾几个项目，维护老项目。这些都要问清楚，你才知道自己大概的工作量有多少。维护旧项目虽然头疼，但是上线压力不大。如果新旧一起来，就要考虑自己是否适合这样的工作强度。\n Q: 我入职的前三个月，要完成什么工作来证明我的能力呢？\n A: 这个问题其实为下一个问题准备，如果我工作表现优秀的话，公司会不会有对应的奖励？\n Q: 多久进行一次调薪，工作绩效是如何计算的？是按项目收益，还是主管决定。\n A: 这个也是了解公司有没有实施奖励制度，通常回答准备中的都要留个心眼，可能一年都不会调薪。\n Q: 公司的五险一金是按什么比例缴的，是按最低标准还是可以自己缴纳更高比例\n A: 一般这个回问HR，如果小公司的话，也可以直接问工程师。五险一金看似没多少，但是每个月累积下来就很多了，这个需要和面试官确认。\n Q: 我今天面试的表现怎样，如果通过之后我还会经过多少轮，怎样的面试流程\n A: 首先可以了解自己的不足，积累经验。也可以开始为下一轮复试做准备\n  总结阶段 一次面试过来，可能筋疲力尽了。回想下自己哪里可以做得更好，简历哪里可以修改的。统计学告诉我们不要选择第一家面试的公司，多面试几家。不要欺骗自己，认真去思考每家的优点和缺点，和你的好朋友聊聊，寻求他们的建议。如果没有拿到offer也没关系，重复上面的步骤，继续努力。两年前我连想都不敢想到美国的大公司工作，而现在的我就在为Google的面试做准备，就算我现在进不了Google又有什么关系呢？我还是在准备过程中学到很多知识。我很享受这段时间。相信自己，努力和汗水总会能得到回报的。\n"
}]